require 'sqlite3'
require 'yaml'

module SecretStore
  # This class models a basic data storage layer for SecretStore objects. This cuts out the need for
  # depending on an ORM, such as ActiveRecord or Sequel, for this small project.
  #
  # An instance of this class represents a connected SQLite 3 database, with tables for storing
  # master password and secret data.
  #
  class Store
    # The database instance used by the store.
    # @return [SQLite3::Database]
    attr_reader :db

    # Connects to database, creating database files and/or tables as required to make the store
    # valid.
    # @param [String] db_connect SQLite connection string, usually just path to file name
    # @return [SecretStore::Store]
    def initialize db_connect
      @db = SQLite3::Database.new( db_connect )
      create_tables
    end

    # Writes master password object to store. There is only ever one password object stored, so
    # all calls to save_password will overwrite existing data.
    # @param [SecretStore::Password] pw password object to be persisted
    # @return [nil]
    def save_password pw
      pw_hash = pw.to_h
      existing = db.execute( 'SELECT bcrypt_salt FROM master_password WHERE id = 1' )
      if existing.empty?
        db.execute( 'INSERT INTO master_password (id, bcrypt_salt, pbkdf2_salt, test_encryption) VALUES ( 1, ?, ?, ? )',
            hash_to_array( pw_hash, [:bcrypt_salt, :pbkdf2_salt, :test_encryption] ) )
      else
        db.execute( 'UPDATE master_password SET bcrypt_salt=?, pbkdf2_salt=?, test_encryption=? WHERE id=1',
            hash_to_array( pw_hash, [:bcrypt_salt, :pbkdf2_salt, :test_encryption] ) )
      end
      nil
    end

    # Reads master password object from store.
    # @return [SecretStore::Password,nil] current master password (hashed)
    def load_password
      record = db.execute( 'SELECT bcrypt_salt, pbkdf2_salt, test_encryption FROM master_password WHERE id = 1' ).first
      if record
        SecretStore::Password.from_h( array_to_hash( record, [:bcrypt_salt, :pbkdf2_salt, :test_encryption] ) )
      end
    end

    # Writes encrypted secret to store. Secrets are identified by the label attribute, so this
    # will create a new entry or overwrite existing one depending on the label.
    # @param [SecretStore::Secret] secret object to be persisted
    # @return [nil]
    def save_secret secret
      secret_hash = secret.to_h
      label = secret_hash[:label]
      existing = db.execute( 'SELECT label FROM secret WHERE label = ?', [label] )
      if existing.empty?
        db.execute( 'INSERT INTO secret (label,iv,crypted_text,auth_tag) VALUES (?,?,?,?)',
            hash_to_array( secret_hash, [:label, :iv, :crypted_text, :auth_tag] ) )
      else
        db.execute( 'UPDATE secret SET iv=?, crypted_text=?, auth_tag=? WHERE label=?',
            hash_to_array( secret_hash, [:iv, :crypted_text, :auth_tag, :label] ) )
      end
      nil
    end

    # Reads encrypted secret with given label from store.
    # @param [String] label identity of secret required
    # @return [SecretStore::Secret,nil] secret, or nil if nothing stored with that label
    def load_secret label
      record = db.execute( 'SELECT label,iv,crypted_text,auth_tag FROM secret WHERE label = ?', [label] ).first
      if record
        SecretStore::Secret.from_h( array_to_hash record, [:label,:iv,:crypted_text,:auth_tag] )
      end
    end

    # Deletes encrypted secret with given label from store.
    # @param [String] label identity of secret to be deleted
    # @return [nil]
    def delete_secret label
      db.execute( 'DELETE FROM secret WHERE label = ?', [label] )
      nil
    end

    # Creates a dump of encrypted and hashed data as a YAML file. This is a form of backup of the
    # crypted data and is equally secure as the original store, in terms of secrecy of the encryption
    # at rest.
    # @param [String] yaml_file path of file to write
    # @return [nil]
    def export_yaml yaml_file
      pw = load_password
      secrets = all_secrets
      all_data = Hash[
        :master_password => pw.to_h,
        :secrets => secrets.map { |s| s.to_h }
      ]

      File.open( yaml_file, 'wb' ) { |f| f.puts YAML.dump( all_data ) }
      nil
    end

    # Converts a YAML dump (previously generated by export_yaml) into a new or existing SQLite store.
    # Note that importing into an existing store will invalidate any existing secrets there unless they
    # happen to have the same master password. There is no current support for safely merging data from
    # multiple secret stores.
    # @param [String] yaml_file path of file to write
    # @param [String] db_connect SQLite connection string, usually just a path to database file name
    # @return [SecretStore::Secret] new store created from previous export
    def self.import_yaml yaml_file, db_connect
      store = self.new( db_connect )
      all_data = YAML.load( File.read( yaml_file ) )

      if pw_hash = all_data[:master_password]
        pw = SecretStore::Password.from_h( pw_hash  )
        store.save_password pw
      end

      if secret_hashes = all_data[:secrets]
        secret_hashes.each do |secret_hash|
          secret = SecretStore::Secret.from_h( secret_hash )
          store.save_secret secret
        end
      end

      store
    end

    # Reads all encrypted secrets from the store.
    # @return [Array<SecretStore::Secret>] all the secrets
    def all_secrets
      records = db.execute( 'SELECT label,iv,crypted_text,auth_tag FROM secret' )
      records.map do |record|
        SecretStore::Secret.from_h( array_to_hash record, [:label,:iv,:crypted_text,:auth_tag] )
      end
    end

    private

    def hash_to_array hash, keys
      keys.map { |k| hash[k] }
    end

    def array_to_hash array, keys
      Hash[ keys.zip(array) ]
    end

    def create_tables
      db.execute <<-SQL
        CREATE TABLE IF NOT EXISTS master_password (
        id INTEGER PRIMARY KEY,
        bcrypt_salt TEXT NOT NULL,
        pbkdf2_salt VARCHAR(20) NOT NULL,
        test_encryption TEXT NOT NULL);
      SQL

      db.execute <<-SQL
        CREATE TABLE IF NOT EXISTS secret (
        label VARCHAR(50) PRIMARY KEY,
        iv VARCHAR(30) NOT NULL,
        crypted_text TEXT NOT NULL,
        auth_tag VARCHAR(30) NOT NULL);
      SQL
    end
  end
end
