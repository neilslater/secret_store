# frozen_string_literal: true

require 'bcrypt'
BCrypt::Engine.cost = 14

module SecretStore
  # This class models a secure password hash. It is a wrapper for BCrypt and PBKDF (password-based
  # key derivation function) methods.
  #
  # An instance of this class represents a single password (without storing the plain password), and
  # it can be "activated" with the correct plain password so that it holds an encryption key.
  #
  class Password
    include CoreMethods
    extend CoreMethods

    # Salt for turning password into checksum using bcrypt hashing algorithm
    # @return [BCrypt::Password]
    attr_reader :bcrypt_salt

    # Salt for turning checksum into key using PBKDF2 algorithm for verifying master password
    # @return [String]
    attr_reader :pbkdf2_salt

    # A test random encryption used to verify that the master password is correct
    # @return [String]
    attr_reader :test_encryption

    # Bcrypt checksum, calculated during call to activate
    # @return [String,nil]
    attr_reader :checksum

    # Create new object from stored String representations.
    # @param [String] bcrypt_salt a BCrypt salt string e.g. "$2a$14$39pphn1Ag848HEujWSowFO"
    # @param [String] pbkdf2_salt salt for key derivation from password, base64 encoded (URL safe variant)
    # @param [String] test_encryption three-part encrypted data to test against supplied password
    # @return [SecretStore::Password]
    def initialize(bcrypt_salt, pbkdf2_salt, test_encryption)
      if BCrypt::Engine.valid_salt?(bcrypt_salt) && bcrypt_salt.length == 29
        @bcrypt_salt = bcrypt_salt
      else
        raise "Bad bcrypt_salt '#{bcrypt_salt}'"
      end
      raise 'Unexpected size of PBKDF salt' if decode_bytes(pbkdf2_salt).length != 16

      @pbkdf2_salt = pbkdf2_salt
      @test_encryption = test_encryption
      @checksum = nil
    end

    # Generates checksum from supplied password. To successfully decrypt stored encrypted values,
    # the password and both salts must both be equal to the values used during encryption.
    # @param [String] plain_password
    # @return [String] checksum suitable for passing to pbkdf2 algorithm
    def activate_checksum(plain_password)
      @checksum = BCrypt::Engine.hash_secret(plain_password, bcrypt_salt)[29, 32]

      # NB This is not enforcing security in Ruby!
      #    Removing this checking step does not allow decryption when user does not have password.
      #    This is here to keep master password synchronised across all items - without it we could
      #    end up with different passwords used for each secret.
      raise 'Incorrect password' unless verify_test_encryption(@checksum, test_encryption)

      @checksum
    end

    # Generates new SecretStore::Password from a given plaintext password. This causes BCrypt
    # to calculate the hash of the supplied plaintext version, so this method is slow.
    # @param [String] plain_password an original password to use in future matching
    # @return [SecretStore::Password] new object
    def self.create(plain_password)
      bcrypt_salt = BCrypt::Engine.generate_salt
      checksum = BCrypt::Engine.hash_secret(plain_password, bcrypt_salt)[29, 32]
      pbkdf2_salt = random_pbkdf2_salt
      test_encryption = create_test_encryption(checksum, pbkdf2_salt)
      new(bcrypt_salt, pbkdf2_salt, test_encryption)
    end

    # Serialise to a Hash. Inverse of .from_h
    # @return [Hash] serialised version of object
    def to_h
      { bcrypt_salt: bcrypt_salt.to_s,
        pbkdf2_salt: pbkdf2_salt,
        test_encryption: test_encryption }
    end

    # De-serialise from a Hash. Inverse of .to_h
    # @param [Hash] h as generated by .to_h
    # @return [SecretStore::Password] new object
    def self.from_h(h)
      new(h[:bcrypt_salt], h[:pbkdf2_salt], h[:test_encryption])
    end

    private

    def self.create_test_encryption(passcode, pbkdf2_salt)
      key = key_from_checksum(passcode, decode_bytes(pbkdf2_salt))
      new_message = SecureRandom.hex(16)
      iv_b64 = encode_bytes(SecureRandom.random_bytes(16))
      crypted_text_b64, auth_tag_b64 = encrypt_string(new_message, key, decode_bytes(iv_b64), 'master').map do |s|
        encode_bytes(s)
      end
      [iv_b64, crypted_text_b64, auth_tag_b64].join(' ~ ')
    end

    def verify_test_encryption(passcode, test_text)
      key = key_from_checksum(passcode, decode_bytes(pbkdf2_salt))
      iv_b64, crypted_text_b64, auth_tag_b64 = test_text.split(' ~ ')
      begin
        decrypt_string(decode_bytes(crypted_text_b64), decode_bytes(auth_tag_b64), key, decode_bytes(iv_b64),
                       'master')
        true
      rescue OpenSSL::Cipher::CipherError
        false
      end
    end
  end
end
