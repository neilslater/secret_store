require 'bcrypt'
BCrypt::Engine.cost = 14

module SecretStore
  # This class models a secure password hash. It is a wrapper for BCrypt and PBKDF (password-based
  # key derivation function) methods.
  #
  # An instance of this class represents a single password (without storing the plain password), and
  # it can be "activated" with the correct plain password so that it holds an encryption key.
  #
  class Password
    include CoreMethods

    # The hashed password
    # @return [BCrypt::Password]
    attr_reader :password

    # Salt for password-based key derivation function, base64 encoded (URL safe variant).
    # @return [String]
    attr_reader :pbkdf2_salt

    # Encryption key, calculated during call to activate_key
    # @return [String,nil]
    attr_reader :key

    # Create new object from stored String representations.
    # @param [String] hashed_password a serialised BCrypt string e.g. "$2a$14$RDZ2LU04FGZh0UHS8leW.OCD0/0UONUz.hobUOS2HKdgqdOqoA/gG"
    # @param [String] pbkdf2_salt salt for key derivation from password, base64 encoded (URL safe variant)
    # @return [SecretStore::Password]
    def initialize hashed_password, pbkdf2_salt = encode_bytes(SecureRandom.random_bytes(16))
      @password = BCrypt::Password.new( hashed_password.to_s )
      if decode_bytes( pbkdf2_salt ).length != 16
        raise "Unexpected size of PBKDF salt"
      end
      @pbkdf2_salt = pbkdf2_salt
      @key = nil
    end

    # Whether or not the hashed password matches to a given plaintext password. This causes BCrypt
    # to calculate the hash of the supplied plaintext version, so this method is slow.
    # @param [String] plain_password a candidate match to the original password
    # @return [Boolean] true if there is a match, false otherwise
    def matches plain_password
      @password == plain_password
    end

    # Generates decryption key from supplied password. To successfully decrypt stored encrypted values,
    # the password and salt must both be equal to the values used during encryption.
    # @param [String] plain_password
    # @return [String] key suitable for encrypting and decrypting secrets based on the password
    def activate_key plain_password
      # NB This is not a security check!
      #    Removing this step will not allow decryptions from bad passwords. Instead they will
      #    generate invalid keys that throw errors during decryption or create gibberish instead
      #    of correct decryptions.
      unless matches( plain_password )
        raise "Incorrect password."
      end
      @key = key_from_password( plain_password, decode_bytes(pbkdf2_salt) )
    end

    # Generates new SecretStore::Password from a given plaintext password. This causes BCrypt
    # to calculate the hash of the supplied plaintext version, so this method is slow.
    # @param [String] plain_password an original password to use in future matching
    # @return [SecretStore::Password] new object
    def self.create plain_password
      self.new( BCrypt::Password.create( plain_password ) )
    end

    # Serialise to a Hash. Inverse of .from_h
    # @return [Hash] serialised version of object
    def to_h
      Hash[
        :hashed_password => password.to_s,
        :pbkdf2_salt => pbkdf2_salt
      ]
    end

    # De-serialise from a Hash. Inverse of .to_h
    # @param [Hash] h as generated by .to_h
    # @return [SecretStore::Password] new object
    def self.from_h h
      self.new( h[:hashed_password], h[:pbkdf2_salt] )
    end
  end
end
