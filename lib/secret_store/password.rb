require 'bcrypt'
BCrypt::Engine.cost = 14

module SecretStore
  # This class models a secure password hash. It is a wrapper for BCrypt and PBKDF (password-based
  # key derivation function) methods.
  #
  # An instance of this class represents a single password (without storing the plain password), and
  # it can be "activated" with the correct plain password so that it holds an encryption key.
  #
  class Password
    include CoreMethods
    extend CoreMethods

    # Salt for turning password into checksum using bcrypt hashing algorithm
    # @return [BCrypt::Password]
    attr_reader :bcrypt_salt

    # Salt for turning checksum into key using PBKDF2 algorithm for verifying master password
    # @return [String]
    attr_reader :pbkdf2_salt

    # A test random encryption used to verify that the master password is correct
    # @return [String]
    attr_reader :test_encryption

    # Bcrypt checksum, calculated during call to activate
    # @return [String,nil]
    attr_reader :checksum

    # Create new object from stored String representations.
    # @param [String] bcrypt_salt a BCrypt salt string e.g. "$2a$14$39pphn1Ag848HEujWSowFO"
    # @param [String] pbkdf2_salt salt for key derivation from password, base64 encoded (URL safe variant)
    # @param [String] test_encryption three-part encrypted data to test against supplied password
    # @return [SecretStore::Password]
    def initialize bcrypt_salt, pbkdf2_salt, test_encryption
      if BCrypt::Engine.valid_salt?( bcrypt_salt ) && bcrypt_salt.length == 29
        @bcrypt_salt = bcrypt_salt
      else
        raise "Bad bcrypt_salt '#{bcrypt_salt}'"
      end
      if decode_bytes( pbkdf2_salt ).length != 16
        raise "Unexpected size of PBKDF salt"
      end
      @pbkdf2_salt = pbkdf2_salt
      @test_encryption = test_encryption
      @checksum = nil
    end

    # Generates checksum from supplied password. To successfully decrypt stored encrypted values,
    # the password and both salts must both be equal to the values used during encryption.
    # @param [String] plain_password
    # @return [String] checksum suitable for passing to pbkdf2 algorithm
    def activate_checksum plain_password
      @checksum = BCrypt::Engine.hash_secret( plain_password, bcrypt_salt )[29,32]

      # NB This is not enforcing security in Ruby!
      #    Removing this checking step does not allow decryption when user does not have password.
      #    This is here to keep master password synchronised across all items - without it we could
      #    end up with different passwords used for each secret.
      unless verify_test_encryption( @checksum, test_encryption )
        raise "Incorrect password"
      end

      @checksum
    end

    # Generates new SecretStore::Password from a given plaintext password. This causes BCrypt
    # to calculate the hash of the supplied plaintext version, so this method is slow.
    # @param [String] plain_password an original password to use in future matching
    # @return [SecretStore::Password] new object
    def self.create plain_password
      bcrypt_salt = BCrypt::Engine.generate_salt
      checksum = BCrypt::Engine.hash_secret( plain_password, bcrypt_salt )[29,32]
      pbkdf2_salt = random_pbkdf2_salt
      test_encryption = create_test_encryption( checksum, pbkdf2_salt )
      self.new( bcrypt_salt, pbkdf2_salt, test_encryption )
    end

    # Serialise to a Hash. Inverse of .from_h
    # @return [Hash] serialised version of object
    def to_h
      Hash[
        :bcrypt_salt => bcrypt_salt.to_s,
        :pbkdf2_salt => pbkdf2_salt,
        :test_encryption => test_encryption
      ]
    end

    # De-serialise from a Hash. Inverse of .to_h
    # @param [Hash] h as generated by .to_h
    # @return [SecretStore::Password] new object
    def self.from_h h
      self.new( h[:bcrypt_salt], h[:pbkdf2_salt], h[:test_encryption] )
    end

    private

    def self.create_test_encryption passcode, pbkdf2_salt
      key = key_from_checksum( passcode, decode_bytes(pbkdf2_salt) )
      new_message = SecureRandom.hex(16)
      iv_b64 = encode_bytes( SecureRandom.random_bytes(16) )
      crypted_text_b64, auth_tag_b64 = encrypt_string( new_message, key, decode_bytes( iv_b64 ), 'master' ).map { |s| encode_bytes( s ) }
      [ iv_b64, crypted_text_b64, auth_tag_b64 ].join(' ~ ')
    end

    def verify_test_encryption passcode, test_text
      key = key_from_checksum( passcode, decode_bytes(pbkdf2_salt) )
      iv_b64, crypted_text_b64, auth_tag_b64 = test_text.split(' ~ ')
      begin
        decrypt_string( decode_bytes( crypted_text_b64 ), decode_bytes( auth_tag_b64 ), key, decode_bytes( iv_b64 ), 'master' )
        true
      rescue OpenSSL::Cipher::CipherError
        false
      end
    end
  end
end
